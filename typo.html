<!doctype html><html lang="zh-CN" class="night"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=4,user-scalable=0" name="viewport"><title>Edeity&#39;s Blog</title><meta name="description" content="Try to be a qualified programmer"><meta property="og:type" content="website"><meta property="og:description" content="Try to be a qualified programmer"><meta property="og:title" content="Edeity&#39;s Blog"><meta property="og:site_name" content="Edeity&#39;s Blog"><meta property="og:url" content="https://blog.edeity.me"><meta property="og:image" content="https://edeity.oss-cn-shenzhen.aliyuncs.com/public/edeity_o.png"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="mainfest" href="/mainfest.json"><link rel="stylesheet" href="/public/css/common.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_707055_4b9og9sc5lx.css"><script>!function(){var e=-1!==window.location.search.indexOf("theme=night")||"night"===window.localStorage.getItem("edeity-theme_theme"),t=-1!==window.location.search.indexOf("theme=light")||"light"===window.localStorage.getItem("edeity-theme_theme");(new Date).getHours();var n=document.querySelector("html");e?n.classList.add("night"):t?n.classList.remove("night"):n.classList.add("night")}(),document.addEventListener("DOMContentLoaded",function(){null!==document.querySelector("ol.toc")&&(document.querySelector("#nav-bar").style.cssText="display: block")})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M3J9QSEE2Z"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-M3J9QSEE2Z")</script><meta name="generator" content="Hexo 5.0.0"></head><body><div class="loading"></div><div id="switch" data-switch="{&#34;toc&#34;:true,&#34;use_pwa&#34;:false}"></div><header class="fullscreen"><div class="toolbar"><i class="iconfont icon-menu"></i></div><h1><a href="/">Edeity&#39;s Blog</a></h1><div class="head-link"><a class="btn waves" href="/"><span><i class="iconfont icon-home">Home </i></span></a><a class="btn waves" href="/about/index.html"><span><i class="iconfont icon-me">About </i></span></a><a class="btn waves" target="_blank" rel="noopener" href="https://github.com/edeity"><span><i class="iconfont icon-github">Github</i></span></a></div></header><div class="some-link"><a class="btn" id="light-or-not"><i class="iconfont icon-light"></i> </a><a style="display:none" class="btn" id="up-to-top"><i class="iconfont icon-up"></i></a></div><div id="nav-bar" style="display:none"><div class="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">编辑器有哪些内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">读取解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%8F%98%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">内存数据结构及其变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E7%89%88"><span class="toc-number">2.2.</span> <span class="toc-text">排版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.</span> <span class="toc-text">元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E7%89%88%E8%A7%84%E5%88%99"><span class="toc-number">2.2.2.</span> <span class="toc-text">排版规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">2.3.</span> <span class="toc-text">渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92"><span class="toc-number">2.4.</span> <span class="toc-text">交互</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E7%BC%96%E8%BE%91%E5%99%A8%E9%81%87%E4%B8%8AWeb"><span class="toc-number">3.</span> <span class="toc-text">当编辑器遇上Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prosemirror"><span class="toc-number">3.1.</span> <span class="toc-text">Prosemirror</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%91%8A%E6%97%B6%E9%97%B4"><span class="toc-number">3.2.</span> <span class="toc-text">广告时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">4.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><main id="content-main" class="section"><div class="list-item"><h1 class="post-title"><a id="「排版软件」浅析" class="article-link" href="">「排版软件」浅析</a></h1><div class="post-meta"><time class="meta published">Dec 27, 2021</time></div><div class="article"><div class="post-excerpt markdown-body"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>约六年多前，笔者初入前端，在大四时成为一名前端实习切图仔。彼时的前端，正在发生翻天覆地的变化：前端框架，React、Vue正攻城略地，步步蚕食jQuery的领土；前端工程化，Gulp/Grunt还没站稳脚尖，又面对着Webpack滔天的洪水；大前端的概念兴起，从不忌讳地表达其一统所有前端设备端的野心。新技术此起彼伏，令人眼花缭乱，又让人深感不安。每个新人，既希望在大变革之际，乘风破浪，一往无前，又害怕卷入乱流，搁浅前滩。</p><p>当时，对前端规划的主流观点：”3年内入门熟练，而后选择细分方向，深入巩固，形成自己的护城河“。而当时有哪些细分方向？几经求索，在知乎大佬的指点下，总结为：内核、富文本、可视化、工程化<small>（当然，如今细分领域更是百花齐放）</small>。可能大佬们也想不到，当年或许随意的几句话，便化成了笔者六年的时光。实习一年，毕业后两年，一心切图，而后机缘巧合下到金山从事新的Web富文本/排版软件开发，后至今日头条，围绕图文创作开展工作，在领域内已三年有余。其实三年的时光，以十年为度量的细分专业领域，显得微不足道，所以笔者在提笔时诚惶诚恐，生怕表述有误，贻笑大方；但又念在自己仍保留一丝世一大的浩然之气，师承WPS，背靠头条，两三口康师傅茉莉花茶下肚壮胆，心一横，便厚脸皮写下此篇“富文本”的介绍类文章，为各位同仁提供一丝经验或思路。</p><p>如有谬误，敬请指正。</p><h2 id="编辑器有哪些内容"><a href="#编辑器有哪些内容" class="headerlink" title="编辑器有哪些内容"></a>编辑器有哪些内容</h2><p>从抽象的角度而言，编辑器可分为四层，分别为「<strong>数据</strong>」、「<strong>排版</strong>」、「<strong>渲染</strong>」、「<strong>交互</strong>」。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/layers.png" alt="layers"></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据，大概分为两方面，其一，是指源<strong>文件和内存数据结构的相互转化</strong>，主要的步骤有：读取、解析、结构化、以及对应的逆运算；其二，是指<strong>发生编辑行为时，内存数据结构变化的过程</strong>，便是常见的增、删、改、查。</p><h4 id="读取解析"><a href="#读取解析" class="headerlink" title="读取解析"></a>读取解析</h4><p>虽源文件类型各异，但万变不离其宗，<strong>读取解析，基本就覆盖了编译原理的主要步骤。</strong>当然，常见的编辑器作为应用层，一般不涉及更底层的硬件优化，往往得到语法树后，便可代表解析的结束。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/compile.png" alt="compiler"></p><p>比如，HTML的解析步骤，基本也能和以上步骤所对应，<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/">此链接</a>有更具体的实现细节：</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/html_parser.png" alt="img"></p><h4 id="内存数据结构及其变化"><a href="#内存数据结构及其变化" class="headerlink" title="内存数据结构及其变化"></a><strong>内存数据结构及其变化</strong></h4><p>在接触的项目中，对数据的操作往往是通过类索引（index）的方式进行。外部视觉看，富文本如同<strong>一维数组</strong>，每项内容代表一个带格式的节点。这种方式的好处：<strong>非常直观。</strong></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作对象：字节跳动</span></span><br><span class="line">insertText(<span class="number">0</span>, <span class="string">&#x27;今日头条,&#x27;</span>); <span class="comment">// 今日头条，字节跳动</span></span><br><span class="line">setBold(<span class="number">1</span>); <span class="comment">// 字节跳动</span></span><br><span class="line">setColor(<span class="number">2</span>, <span class="string">&#x27;blue&#x27;</span>); <span class="comment">// 字节跳动</span></span><br></pre></td></tr></table></figure><p>但具体实现则不然。</p><p>出于性能考虑，需要引入“区间”（range）概念，使数据更紧凑。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    start: <span class="number">0</span>, end: <span class="number">100</span>, content: <span class="string">&#x27;字节....跳动&#x27;</span>, style: &#123; <span class="comment">/***/</span> &#125;,</span><br><span class="line">    start: <span class="number">101</span>, end: <span class="number">200</span>, content: <span class="string">&#x27;今日....头条&#x27;</span>, style: &#123; <span class="comment">/***/</span> &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>另一方面，会引入“偏移”（offset）概念，其原因是在修改数据时，更新某一个区间不会导致所有区间雪崩式变动。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如每个区间的start，可能指的是相对前一区间的偏移量</span></span><br><span class="line"></span><br><span class="line">[&#123;</span><br><span class="line">    startOffset: <span class="number">0</span>, endOffset: <span class="number">100</span>, content: <span class="string">&#x27;字节....跳动&#x27;</span>, style: &#123; <span class="comment">/***/</span> &#125;,</span><br><span class="line">    startOffset: <span class="number">0</span>, endOffset: <span class="number">100</span>, content: <span class="string">&#x27;今日....头条&#x27;</span>, style: &#123; <span class="comment">/***/</span> &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>为了兼顾增删改查，一种通用的方法是确定某种大小关系，以此构建红黑树（<small>理想情况下，增删改查均为<code>O(log(n))</code>的平衡二叉树</small>），再针对高频操作或瓶颈加以优化。这是在前司学到的技巧，在 VS Code 的 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation">Text Buffer Reimplementation</a> 优化中也有类似的概念。</p><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>排版，可约等于<strong>数据在空间的排列方式</strong>。</p><p>影响排版的要素有二，其一是元素的<strong>自身属性</strong>，另一个则是应用的<strong>排版规则</strong>。对比极其考虑计算机基础的数据层，排版则更多和“业务”（<small>比如不同的排版标准</small>）相结合。</p><p>富文本编辑器中的「富」，狭义指的是多格式的图文，广义则指<strong>一切能在前端设备展示的元素</strong>，可以是图片或文字，也可以超链接，视频，文件，乃至各种内联应用。</p><h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><p>前端最常打交道的便是图片和文字。但应注意，因为浏览器要考虑跨平台性，文字或图片能应用的Css样式，往往已经是抽象或阉割后的属性。比如字体，脱离Css，可以找到更进一步的描述：<a target="_blank" rel="noopener" href="https://freetype.org/freetype2/docs/glyphs/index.html">FreeType</a>；而对于图片，不同图片也存在差异的（<a target="_blank" rel="noopener" href="https://www.w3.org/TR/PNG/">PNG</a>、<a target="_blank" rel="noopener" href="https://www.w3.org/Graphics/JPEG/itu-t81.pdf">JPEG</a>）。在个别场合，图片在Web端和其它端上表现不一致，便可能是某些被阉割的属性在起作用。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/font.png" alt="字体"></p><h4 id="排版规则"><a href="#排版规则" class="headerlink" title="排版规则"></a>排版规则</h4><p>排版规则极其复杂。前端熟悉的盒子模型、弹性布局便是不同的排版规则。显而易见，相同元素在不同排版规则下的表现是不同的。有趣的是，在字体内部，也有着各种繁琐的规则。比如：因为<a target="_blank" rel="noopener" href="https://freetype.org/freetype2/docs/glyphs/glyphs-4.html">字距对</a>（Kerning pairs）属性，VA 和 V、A 所占空间是不同的。文字内排版规则，也常和语种关联。比如涉及到阿拉伯语时，字体会发生“形变”：ب س ب ب 和 بسبب是相同的；而当ltr（从左到右）和rtl（从右到左）文字相结合时，又会涉及 <a target="_blank" rel="noopener" href="https://unicode.org/reports/tr9/tr9-17.html">Bidi</a> 双向算法。</p><p>遗憾的是，笔者未能深入实现某个排版规则，仅在此列举一二。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>「数据」经过「排版」处理后，将得到的具体元素位置信息提交到前端设备的过程，便是「渲染」。</p><p>在笔者接触的工作内容中，富文本中的“渲染”要比图形学中的“渲染”简单很多。在富文本的渲染中，会强调<strong>调度</strong>（scheduler）和<strong>层级</strong>（layer），也注重<strong>可视区</strong>（Viewport）。这基本上和一些人机交互经验有关，在性能吃紧的场合，会优先渲染可视区范围内重要层级的内容，而推迟可视区外、或不重要的内容，也即是分块、分阶段渲染。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/render.png" alt="渲染"></p><p>而优化渲染模块时，会感到某些技巧似曾相识。比如：<strong>计算</strong>（非排版部分）和<strong>提交</strong>两者分开（<small>类比React中的render和commit两个概念</small>)，有助于保留「空间换时间」的可能，尽可能提前处理耗时操作，从而实现诸如离线渲染，双缓冲等策略，避免白屏时间过长。</p><p>当然，也接触一些新颖的概念，比如：“字体回退（Font Fallbacks）”。由于版权等限制，在涉及某些商用字体的情况下，编辑器会有回退策略，从列表中返回相似的字体，类似于Css中的<code>font-family: sans-serif, &#39;微软雅黑&#39;</code>。<code>Emoji</code>作为特殊的字体，因存在平台差异，也需要有对应的回退。</p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>交互层面，则是大多数前端工程师所熟悉的领域了。交互可分为两方面，一方面指<strong>和编辑器的互动</strong>，另一方面则是等<strong>通常意义的前端组件</strong>（<small>工具栏，侧边栏等，和编辑器互动性较弱</small>）。</p><p>一个完整的编辑流程，通常由<strong>交互</strong>触发（<small>比如输入、拖拽等</small>），进而修改<strong>数据</strong>，触发<strong>排版</strong>，最后通知<strong>渲染器</strong>进行渲染刷新。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/update.png" alt="更新"></p><p>对应Web前端，可以是大家熟悉的步骤：JavaScript（<small>调用Api变更数据</small>） -&gt; 触发排版 （<small>Style、Layout</small>） -&gt; 通知渲染（<small>Paint、Composite</small>）。因为排版引擎是浏览器的重要组成部分，当然不会缺少这些抽象。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/fe_update.png" alt="浏览器更新步骤"></p><p>在此还有一个有趣的概念：<strong>点击测试</strong>（<a target="_blank" rel="noopener" href="https://www.w3.org/wiki/Hit_Testing">Hittest</a>）。可以简单认为其为一个纯函数，入参屏幕坐标（x，y），返回结果为当前坐标的数据上下文（比如索引、节点、格式等）。通过点击测试，能有效建立交互和数据、排版的通道，从而实现各种自定义交互。（<small>比如：模拟 Hover 效果：通过监听鼠标移动，检索当前鼠标坐标是否和某个文本元素碰撞，如果碰撞，即认为发生 Hover 行为</small>）。这种方式能突破通常意义的前端限制，比如允许不受层次限制，也可以在其它载体（<small>比如 Web 端的 Canvas </small>）模拟熟悉的交互行为（<small>比如自定义光标和选区</small>）。一个简单的点击测试前端实现：对有序的排版数据做二分查找，再顺序遍历无序元素（<small>比如浮动元素</small>）。</p><h2 id="当编辑器遇上Web"><a href="#当编辑器遇上Web" class="headerlink" title="当编辑器遇上Web"></a>当编辑器遇上Web</h2><p>「数据」+「排版」+「渲染」+「交互」，构成了一个<strong>平台无关</strong>的富文本编辑器实现<strong>。</strong></p><p>但其复杂程度也往往让人望而却步。所幸的是，Web的蓬勃发展降低了实现富文本编辑器的难度，驾驭HTML + CSS + JS 三剑客的浏览器，在极大程度上，屏蔽了数据、排版、渲染上的实现难度，使开发者能将更多的精力聚焦在「交互」细节上。</p><p>在Web富文本领域，有一个相对通用的等级：</p><ul><li>Lv0：<code>TextArea</code> + <code>document.execCommand</code></li><li>Lv1：<code>contenteditable</code> + <code>observerable</code> + <code>parser</code></li><li>Lv2：自排（指排版）自绘（指渲染）</li></ul><p>Lv0 级别的编辑器，在表现形式和兼容性上存在非常大的局限，更多是作为一些表单组件使用。</p><p>Lv1 级别的编辑器（<small>多数开源的富文本都是这种实现方式</small>），在监听DOM变化时，通过语法模型约束，能较大程度实现编辑行为的相对统一，但对一些非标准化的行为（比如光标、选区），在不同的浏览器上会存在各种细微的差别或Bug。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/diff.png" alt="diff"></p><p>Lv0、Lv1 的痛点，在 Lv2 级别的编辑器中能得到有效的解决。但Lv2级别的编辑器，也存在比较明显的缺陷。其一，任何细小的功能，都可能需要考虑数据、排版、渲染、交互各层级的实现，从而导致研发成本过高；其二，脱离前端基础，对轻量级前端集成能力较差，比如，很难在基于 OOXML （<small>DOCX 的源格式</small>）的排版软件上，实现类 Notion 的产品。</p><p>以上层级<strong>只代表实现的难度</strong>（或对细节的掌控力度），而不代表产品的好坏，毕竟绝大多数产品，是以需求而不是技术为导向。笔者曾有幸参与后两种编辑器的研发，因此有一个不成熟的观点：“在非专业商用场合，一个以兼顾用户体验、开发进度为目的 Web 富文本编辑器，Lv1 &gt; Lv2”。 理由很简单，Web 端的表现方式已经足够灵活：其<strong>排版方式能覆盖绝大多数常用的场景</strong>；也足够优秀：现代型浏览器对性能的压榨和各种奇淫巧技的运用已经到了令人发指的地步（<small>可通过<a target="_blank" rel="noopener" href="https://v8.dev/blog">V8博客</a>窥探一二</small>），断不是单线程的Js、或缩水版多线程（<small>指 WebWorker </small>）所能比拟的，<strong>自排自绘的 Web 编辑器或多或少都会遇到性能瓶颈</strong>，在流畅程度上逊色于基于 <code>contenteditable</code> 的浏览器。最重要的是，构建于 Html 之上的编辑器，学习成本相对平顺，<strong>研发和维护成本要低于</strong>自排自绘的编辑器。因为，如果团队不具备编辑器相关的深厚研发能力，Lv1 级别的 Web 富文本编辑器是不二选择。</p><h3 id="Prosemirror"><a href="#Prosemirror" class="headerlink" title="Prosemirror"></a>Prosemirror</h3><p>在此安利下 <a target="_blank" rel="noopener" href="https://prosemirror.net/docs/">Prosemirror</a> 框架，作者 <a target="_blank" rel="noopener" href="https://github.com/marijnh">Marijn Haverbeke</a>，同时也是 <a target="_blank" rel="noopener" href="https://codemirror.net/">CodeMirror</a>、<a target="_blank" rel="noopener" href="https://github.com/acornjs/acorn">acorn</a>、<a target="_blank" rel="noopener" href="https://lezer.codemirror.net/">lezer</a> 的作者，已经在 Web 编辑器领域沉浸了十多年，目前作为独立的软件开发者，在开源社区中非常活跃。</p><p><img src="https://edeity.oss-cn-shenzhen.aliyuncs.com/2021/prosemirror.png" alt="prosemirror"></p><p>Prosemirror 是一款优秀的框架，实现了编辑器的基本特性，清晰的语法解析支持，完备的事务系统，甚至支持多人协作等。但与其它富文本组件不同，Prosemirror 定位更像是一个编辑器的<strong>骨架</strong>，而不是一个完备的编辑器。这意味着，开发者可以基于这个骨架，灵活地实现各形态各异的编辑器。既可以类UEditor 这样的富文本，也可以是类 Notion 的协作工作台，或者是类秀米那样的图文排版工具（<small>只是说知道有基于此框架的同类型实现，并不指以上工具采用此框架</small>）。如果开发者<strong>对编辑器的有强烈的定制化要求</strong>，Prosemirror 不逞多让。但在使用的过程中，Prosemirror 也有比较明显的弊端。一方面该框架由外国大神编写，仅包含少量的英文示例和相对晦涩的 API，同时编辑器也是相对小众的领域，从而导致中文文档匮乏；另一方面，Prosemirror 的规划更偏向于扩展性骨架，无法即插即用（<small>作者原话：The core library is not an easy drop-in component—we are prioritizing modularity and customizability over simplicity</small>），导致采用Prosemirror 的学习和使用成本要比其它框架陡峭，劝退了一部分开发者。</p><h3 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h3><p>那么，是否有某种框架，既能最大限度保留 Prosemirror 的拓展性，又能提供各种插件，以即插即用呢？<strong>Syllepsis 了解一下</strong>。</p><p><a target="_blank" rel="noopener" href="https://github.com/bytedance/syllepsis">Syllepsis</a> 诞生于头条号，初衷是服务于专业作者创作的一个富文档编辑器，后延伸到其它部门，其内部版 <code>syl-editor</code> 已被今日头条、西瓜视频、幸福里、懂车帝等超过30+的部门打磨使用。可以简单认为，Syllepsis 是建立在 Prosemirror 基础上的 <strong>React</strong> <strong>组件</strong>（<small>曾经也有Vue版本，但由于上层原因，如今只保留可拓展的接口</small>），其目的只有两个：</p><ol><li>提供常见的编辑插件，更简洁的接口，保证开箱可用，简单可配置。</li><li>保留 Prosemirror 易拓展的特性，在现有插件无法满足需求时，仍保留定制的能力。</li></ol><p>当然，该项目在开源方面还在起步阶段，你可通过<a target="_blank" rel="noopener" href="https://bytedance.github.io/syllepsis/#/zh-cn/about">文档</a>进一步了解 Syllepsis 的能力。笔者认为，构造一个活跃的生态才是开源项目能源远流长的核心要素，欢迎所有同学在 <a target="_blank" rel="noopener" href="https://github.com/bytedance/syllepsis/issues">Issue</a> 上畅所欲言，反馈 Bug，提供对富文本编辑器的见解或需求。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>编辑器其实是一个非常复杂的模块，单凭个人难以实现所有的内容。笔者也只是在各前辈积累的基础上，结合自身的工作内容，讲述自己的见解。限于篇幅和能力，很多地方只是一笔带过，欢迎同行勘察和补充。最后，感谢 WPS 的烈锦同学，阿里的小海豹同学提供写作灵感和修改建议。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a target="_blank" rel="noopener" href="http://taligarsiel.com/Projects/howbrowserswork1.htm">浏览器工作原理</a></li><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/samples/gg193983(v=vs.85)">Svg Vs Canvas性能对比</a></li></ol></div></div></div><div class="more section"><div class="pre"><a class="article-link" href="/half_year_in_toutiao.html"><i class="iconfont icon-right"></i> <span>2021，挑战和机遇</span></a></div><div class="next"><a class="article-link" href="/how_to_compare_text.html">Mr. Myers <i class="iconfont icon-right"></i></a></div></div></main></body><footer class="section fullscreen"><div class="footer-desc">Edeity © 2015-2022 · powered by hexo</div></footer><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script src="/public/js/init.js"></script></html>